#include "pch.h"

#include "parse.h"

#include "PreprocessSource.h"
#include "ReadFile.h"
#include "ReadFileAsLines.h"
#include "Trim.h"
#include "data.h"
#include "fn_CompactSpaces.h"
#include "fn_ExtractIdentifier.h"
#include "fn_ParseEnum.h"
#include "fn_ParseFn.h"
#include "fn_ParseStructClass.h"
// #include "fn_WriteFile.h"
// #include "fn_fs_exists_total.h"
// #include "fn_reinterpret_as_u8string_view.h"
#include "sc_Args.h"

namespace fs = std::filesystem;

// const char* const k_autogeneratedWarningLine = "// AUTOGENERATED FILE, DO NOT EDIT!";
const std::set<fs::path> k_validSourceExtensions = {".h", ".hpp", ".hxx"};
const std::set<fs::path> k_fileListExtensions = {".txt", ".lst"};

// Resolve `pathsToDo` argument to list of files.
std::optional<std::vector<fs::path>> ResolveArgsSources(std::vector<fs::path> pathsToDo,
                                                        bool verbose) {
    std::set<fs::path> pathsDone;
    std::vector<fs::path> sources;

    while (!pathsToDo.empty()) {
        auto f = std::move(pathsToDo.back());
        pathsToDo.pop_back();
        std::error_code ec;
        auto cf = fs::canonical(f, ec);
        if (ec) {
            fmt::print(stderr, "File doesn't exist: `{}`\n", f);
            return std::nullopt;
        }
        if (pathsDone.contains(cf)) {
            // Duplicate.
            continue;
        }
        pathsDone.insert(cf);
        auto ext = cf.extension();
        if (k_validSourceExtensions.contains(ext)) {
            sources.push_back(cf);
        } else if (k_fileListExtensions.contains(ext)) {
            auto pathList = ReadFileAsLines(f);
            if (!pathList) {
                fmt::print(stderr, "Can't read file list from `{}`.\n", f);
                return std::nullopt;
            }
            // sources.reserve(sources.size() + pathList->size());
            for (auto& p : *pathList) {
                if (!p.empty()) {
                    pathsToDo.push_back(std::move(p));
                }
            }
        } else {
            // Ignore this file.
            if (verbose) {
                fmt::print(stderr, "Ignoring file with extension `{}`: {}", ext, f);
            }
        }
    }

    std::sort(sources.begin(), sources.end());
    return sources;
}

std::optional<EntityKind> StringToEntityKind(std::string_view sv) {
    static const std::unordered_map<std::string_view, EntityKind> m = {
        {"enum", EntityKind::enum_},
        {"fn", EntityKind::fn},
        {"struct", EntityKind::struct_},
        {"class", EntityKind::class_},
        {"using", EntityKind::using_},
        {"inlvar", EntityKind::inlvar},
        {"memfn", EntityKind::memfn},
    };

    // Force completeness of map.
    [[maybe_unused]] auto _ = [](EntityKind ek) {
        switch (ek) {
            case EntityKind::enum_:
            case EntityKind::fn:
            case EntityKind::struct_:
            case EntityKind::class_:
            case EntityKind::using_:
            case EntityKind::inlvar:
            case EntityKind::memfn:
                break;
        }
    };

    auto it = m.find(sv);
    if (it == m.end()) {
        return std::nullopt;
    }
    return it->second;
}

std::expected<EntityProperties, std::string> ParsePreprocessedSource(
    const PreprocessedSource& pps) {
    struct {
        std::optional<EntityKind> entityKind;
        absl::flat_hash_map<NeedsKind, std::vector<std::string>> needsByKind;
        std::optional<std::string> namespace_;
        std::optional<Visibility> visibility;
    } in;
    for (auto& sc : pps.specialComments) {
        auto keyword = enum_from_name<SpecialCommentKeyword>(sc.keyword);
        if (!keyword) {
            return std::unexpected(fmt::format("Invalid keyword: {}", sc.keyword));
        }

        auto addToNeeds = [&in, &sc](NeedsKind k) {
            auto& v = in.needsByKind[k];
            v.reserve(v.size() + sc.list.size());
            for (auto& sv : sc.list) {
                v.emplace_back(sv);
            }
        };

        switch (*keyword) {
            case SpecialCommentKeyword::entity:
                if (in.entityKind) {
                    return std::unexpected(
                        fmt::format("Duplicated `#entity`, first value: {}, second value: {}",
                                    enum_name(*in.entityKind),
                                    fmt::join(sc.list, ", ")));
                }
                if (sc.list.size() != 1) {
                    return std::unexpected(fmt::format("`#entity` need a single value, got: {}",
                                                       fmt::join(sc.list, ", ")));
                }
                in.entityKind = enum_from_name<EntityKind>(sc.list.front());
                if (!in.entityKind) {
                    return std::unexpected(fmt::format("Invalid `#entity`: {}", sc.list.front()));
                }
            case SpecialCommentKeyword::fdneeds:
                addToNeeds(NeedsKind::forwardDeclaration);
                break;
            case SpecialCommentKeyword::oedneeds:
                addToNeeds(NeedsKind::opaqueEnumDeclaration);
                break;
            case SpecialCommentKeyword::needs:
                addToNeeds(NeedsKind::declaration);
                break;
            case SpecialCommentKeyword::defneeds:
                addToNeeds(NeedsKind::definition);
                break;
            case SpecialCommentKeyword::namespace_:
                if (in.namespace_) {
                    return std::unexpected(fmt::format("Duplicated `#namespace`, first value: {}, "
                                                       "second value: {}",
                                                       *in.namespace_,
                                                       fmt::join(sc.list, ", ")));
                }
                if (sc.list.size() != 1) {
                    return std::unexpected(fmt::format("`#namespace` need a single value, got: {}",
                                                       fmt::join(sc.list, ", ")));
                }
                in.namespace_ = sc.list.front();
                break;
            case SpecialCommentKeyword::visibility:
                if (in.visibility) {
                    return std::unexpected(fmt::format("Duplicated `#visibility`, first value: "
                                                       "{}, second value: {}",
                                                       enum_name<Visibility>(*in.visibility),
                                                       fmt::join(sc.list, ", ")));
                }
                if (sc.list.size() != 1) {
                    return std::unexpected(fmt::format("`#visibility` need a single value, got: {}",
                                                       fmt::join(sc.list, ", ")));
                }
                in.visibility = enum_from_name<Visibility>(sc.list.front());
                if (!in.visibility) {
                    return std::unexpected(
                        fmt::format("Invalid `#visibility` value: {}", sc.list.front()));
                }
                break;
        }
    }
    if (!in.entityKind) {
        return std::unexpected("Missing `#entity`");
    }
    for (auto& [_, v] : in.needsByKind) {
        std::sort(v.begin(), v.end());
    }
    return EntityProperties{
        .entityKind = *in.entityKind,
        .needsByKind = std::move(in.needsByKind),
        .namespace_ = std::move(in.namespace_),
        .visibility = in.visibility.value_or(EntityProperties::k_defaultVisibility)};
}

int main(int argc, char* argv[]) {
    absl::InitializeLog();

    CLI::App app("C++ boilerplate generator", "NMT");

    Args args;

    app.add_option(
        "-s,--sources",
        args.sources,
        fmt::format("List of source files ({}) or files containing a list of source files ({}, one "
                    "path on each line) or any other files (they'll be ignored)",
                    fmt::join(k_validSourceExtensions, ", "),
                    fmt::join(k_fileListExtensions, ", ")));
    app.add_option("-o,--output-dir",
                   args.outputDir,
                   "Output directory, will be created or content erased/updated, as needed")
        ->required();
    app.add_option("-v,--verbose", args.verbose, "Print more diagnostics");

    CLI11_PARSE(app, argc, argv);

    auto sourcesOr = ResolveArgsSources(args.sources, args.verbose);
    if (!sourcesOr) {
        return EXIT_FAILURE;
    }
    auto sources = std::move(*sourcesOr);

    fmt::print("sources: {}\n", fmt::join(sources, ", "));

    std::unordered_map<std::string, Entity> entities;

    for (auto& sf : args.sources) {
        auto maybeSource = ReadFile(sf);
        if (!maybeSource) {
            fmt::print(stderr, "Can't open file for reading: `{}`", sf);
            return EXIT_FAILURE;
        }
        auto& source = *maybeSource;

        auto ppsOr = PreprocessSource(source);
        if (!ppsOr) {
            fmt::print(stderr, "{} in {}", ppsOr.error(), sf);
            return EXIT_FAILURE;
        }

        const bool hasSpecialComments = !ppsOr->specialComments.empty();
        if (!hasSpecialComments) {
            if (args.verbose) {
                fmt::print(stderr, "Ignoring file without special comments: {}\n", sf);
            }
            continue;
        }

        auto epOr = ParsePreprocessedSource(*ppsOr);
        if (!epOr) {
            fmt::print(stderr, "Error: {}\n", epOr.error());
            return EXIT_FAILURE;
        }
        auto& ep = *epOr;
        ep.Print();

        // Find the first nonCommentCode after the first specialComment.
        CHECK(hasSpecialComments);
        auto& firstSpecialComment = ppsOr->specialComments.begin()->keyword;
        auto it = ppsOr->nonCommentCode.begin();
        while (it != ppsOr->nonCommentCode.end() && it->data() < firstSpecialComment.data()) {
            ++it;
        }
        if (it == ppsOr->nonCommentCode.end()) {
            // All nonCommentCode is before the first specialComment.
            fprintf(stderr,
                    "All code is before the first special comment. Move at leat the first special "
                    "comment before the main entity in the file.\n");
            return EXIT_FAILURE;
        }
        // Assemble all the remaining code into a single string.
        std::string code;
        for (; it != ppsOr->nonCommentCode.end(); ++it) {
            code += *it;
            code += ' ';
        }

        auto f = [&ep, &sf, &entities](
                     std::expected<std::pair<std::string, std::string>, std::string> edOr)
            -> std::expected<std::monostate, std::string> {
            if (!edOr) {
                return std::unexpected(fmt::format("Failed to parse {} in {}, reason: {}",
                                                   enum_name(ep.entityKind),
                                                   sf,
                                                   edOr.error()));
            }
            auto entity = Entity{.name = edOr->first,
                                 .path = sf,
                                 .props = std::move(ep),
                                 .lightDeclaration = std::move(edOr->second)};
            auto itb = entities.insert(std::make_pair(std::move(edOr->first), std::move(entity)));
            if (!itb.second) {
                return std::unexpected(fmt::format("Duplicate name: `{}`, first {} then {}.",
                                                   entity.name,
                                                   enum_name(itb.first->second.props.entityKind),
                                                   enum_name(entity.props.entityKind)));
            }
            return std::monostate{};
        };

        switch (ep.entityKind) {
            case EntityKind::enum_: {
                if (auto r = f(ParseEnum(code)); !r) {
                    fmt::print(stderr, "Failed to parse {}, reason: {}\n", sf, r.error());
                    return EXIT_FAILURE;
                }
            } break;
            case EntityKind::fn:
                // #define TRYQ(EXPECTED) if(auto x = (EXPECTED); !x.has_value()) { return
                // std::unexpected(x); } TRYQ(f(ParseFunction(code)));
                if (auto r = f(ParseFunction(code)); !r) {
                    return EXIT_FAILURE;  // std::unexpected(r.error());
                }
                break;
            case EntityKind::struct_:
                break;
            case EntityKind::class_:
                break;
            case EntityKind::using_:
                break;
            case EntityKind::inlvar:
                break;
            case EntityKind::memfn:
                break;
        }
        /*
switch (ep.entityKind) {
    case EntityKind::enum_:
//                f(ParseEnum(ppsOr->), EntityKind::enum_);
        break;
    case EntityKind::fn:
//              f(ParseFunctionDeclaration(ppsOr->ppSource), EntityKind::fn);
        break;
    case EntityKind::sc:
//            f(ParseStructClassDeclaration(ppsOr->ppSource), EntityKind::sc);
        break;
}
         */
    }

#if 0

	std::error_code ec;
    fs::create_directories(args.outputDir, ec);
    LOG_IF(FATAL, ec) << fmt::format("Can't create output directory `{}`.", args.outputDir);

    auto dit = fs::directory_iterator(args.outputDir, fs::directory_options::none, ec);
    LOG_IF(FATAL, ec) << fmt::format("Can't get listing of output directory `{}`.", args.outputDir);
    struct path_hash {
        size_t operator()(const fs::path p) const {
            return hash_value(p);
        }
    };
    std::unordered_set<fs::path, path_hash> remainingExistingFiles;
    for (auto const& de : dit) {
        auto ext = de.path().extension().string();
        if (ext == ".h" || ext == ".cpp") {
            remainingExistingFiles.insert(de.path());
        }
    }
    std::vector<fs::path> currentFiles;

    struct Includes {
        std::vector<std::string> generateds, locals, externalsInDirs, externalWithExtension,
            externalsWithoutExtension, forwardDeclarations;
        void addHeader(std::string_view s) {
            assert(!s.empty());
            std::vector<std::string>* v{};
            if (s[0] == '"') {
                v = &locals;
            } else if (s.find('/') != std::string_view::npos) {
                v = &externalsInDirs;
            } else if (s.find('.') != std::string_view::npos) {
                v = &externalWithExtension;
            } else {
                v = &externalsWithoutExtension;
            }
            v->push_back(std::string(s));
        };
        std::string render() {
            std::string content;
            auto addHeaders = [&content](std::vector<std::string>& v) {
                if (!v.empty()) {
                    if (!content.empty()) {
                        content += "\n";
                    }
                    std::sort(v.begin(), v.end());
                    for (auto& s : v) {
                        content += fmt::format("#include {}\n", s);
                    }
                }
            };
            addHeaders(generateds);
            addHeaders(locals);
            addHeaders(externalsInDirs);
            addHeaders(externalWithExtension);
            addHeaders(externalsWithoutExtension);
            if (!forwardDeclarations.empty()) {
                if (!content.empty()) {
                    content += "\n";
                }
                std::sort(forwardDeclarations.begin(), forwardDeclarations.end());
                for (auto& s : forwardDeclarations) {
                    content += s;
                }
            }
            return content;
        }
        void addNeedsAsHeaders(const std::unordered_map<std::string, Entity>& entities,
                               const Entity& e,
                               const std::vector<std::string>& needs,
                               const fs::path& outputDir) {
            std::vector<std::string> additionalNeeds;
            const std::vector<std::string>* currentNeeds = &needs;
            while (!currentNeeds->empty()) {
                additionalNeeds = addNeedsAsHeadersCore(entities, e, *currentNeeds, outputDir);
                // TODO: prevent infinite loop because of some circular dependency.
                currentNeeds = &additionalNeeds;
            }
        }
        // Return additional needs coming from the enums which have needs for their
        // opaque-enum-declaration.
        std::vector<std::string> addNeedsAsHeadersCore(
            const std::unordered_map<std::string, Entity>& entities,
            const Entity& e,
            const std::vector<std::string>& needs,
            const fs::path& outputDir) {
            std::vector<std::string> additionalNeeds;
            for (auto& need : needs) {
                LOG_IF(FATAL, need.empty()) << "Empty need name.";
                if (need[0] == '<' || need[0] == '"') {
                    addHeader(need);
                } else {
                    std::string_view needName = need;
                    const bool refOnly = needName.back() == '*';
                    if (refOnly) {
                        needName.remove_suffix(1);
                    }
                    LOG_IF(FATAL, needName == e.name)
                        << fmt::format("Entity `{}` can't include itself.", e.name);
                    auto it = entities.find(
                        std::string(needName));  // TODO(optimize): could use heterogenous lookup.
                    LOG_IF(FATAL, it == entities.end()) << fmt::format(
                        "Entity `{}` needs `{}` but it's missing.", e.name, needName);
                    auto& ne = it->second;
                    switch (ne.kind) {
                        case EntityKind::enum_:
                        case EntityKind::sc:
                            break;
                        case EntityKind::fn:
                            LOG_IF(FATAL, refOnly) << fmt::format(
                                "Entity `{}` needs `{}` but it's a function and can't "
                                "be forward declared.",
                                e.name,
                                need);
                            break;
                    }
                    if (refOnly) {
                        forwardDeclarations.push_back(fmt::format("{};", ne.lightDeclaration));
                        additionalNeeds.insert(
                            additionalNeeds.end(), ne.declNeeds.begin(), ne.declNeeds.end());
                    } else {
                        auto filename =
                            fmt::format("{}_{}.h", EntityKindShortName(ne.kind), ne.name);
                        auto path = outputDir / fs::path(reinterpret_as_u8string_view(filename));
                        generateds.push_back(fmt::format("\"{}\"", path));
                    }
                }
            }
            return additionalNeeds;
        }
#endif
#if 0
    for (auto& [_, e] : entities) {
        std::string headerContent = fmt::format("{}\n#pragma once\n", k_autogeneratedWarningLine);
        {
            Includes includes;
            includes.addNeedsAsHeaders(entities, e, e.declNeeds, args.outputDir);
            switch (e.kind) {
                case EntityKind::enum_:
                    includes.addNeedsAsHeaders(entities, e, e.defNeeds, args.outputDir);
                case EntityKind::fn:
                case EntityKind::sc:
                    break;
            }
            auto renderedHeaders = includes.render();
            if (!renderedHeaders.empty()) {
                headerContent += fmt::format("\n{}", renderedHeaders);
            }
        }
        headerContent += "\n";
        switch (e.kind) {
            case EntityKind::enum_:
            case EntityKind::sc:
                headerContent += fmt::format("#include \"{}\"\n", e.path);
                break;
            case EntityKind::fn:
                headerContent += fmt::format("{};\n", e.lightDeclaration);
                break;
        }
        fmt::print("Processed {} from {}\n", e.name, e.path);
        auto headerPath =
            args.outputDir / fmt::format("{}_{}.h", EntityKindShortName(e.kind), e.name);
        remainingExistingFiles.erase(headerPath);
        currentFiles.push_back(headerPath);
        auto existingHeaderContent = ReadFile(headerPath);
        if (existingHeaderContent != headerContent) {
            LOG_IF(FATAL, !WriteFile(headerPath, headerContent))
                << fmt::format("Couldn't write {}.", headerPath);
        }  // Else no change, no need to write.

        switch (e.kind) {
            case EntityKind::enum_:
                // defNeeds were processed into the header.
                break;
            case EntityKind::sc:
                LOG_IF(FATAL, !e.defNeeds.empty())
                    << fmt::format("Struct/class `{}` is not supposed to have defNeeds.\n", e.name);
                break;
            case EntityKind::fn: {
                std::string cppContent =
                    fmt::format("{}\n#include \"{}\"\n", k_autogeneratedWarningLine, headerPath);
                {
                    Includes includes;
                    includes.addNeedsAsHeaders(entities, e, e.defNeeds, args.outputDir);
                    auto renderedHeaders = includes.render();
                    if (!renderedHeaders.empty()) {
                        cppContent += fmt::format("\n{}", renderedHeaders);
                    }
                }
                cppContent += fmt::format("\n#include \"{}\"\n", e.path);
                auto cppPath =
                    args.outputDir / fmt::format("{}_{}.cpp", EntityKindShortName(e.kind), e.name);
                remainingExistingFiles.erase(cppPath);
                currentFiles.push_back(cppPath);
                auto existingCppContent = ReadFile(cppPath);
                if (existingCppContent != cppContent) {
                    LOG_IF(FATAL, !WriteFile(cppPath, cppContent))
                        << fmt::format("Couldn't write {}.", cppPath);
                }  // Else no change, no need to write.
            } break;
        }
    }
    for (auto& f : remainingExistingFiles) {
        fs::remove(f, ec);  // Ignore if couldn't remove it.
    }
    std::string fileListContent;
    std::sort(currentFiles.begin(), currentFiles.end());
    for (auto& c : currentFiles) {
        fileListContent += fmt::format("{}\n", c);
    }
    auto filesPath = args.outputDir / "files.txt";
    auto existingFileListContent = ReadFile(filesPath);
    if (existingFileListContent != fileListContent) {
        LOG_IF(FATAL, !WriteFile(filesPath, fileListContent))
            << fmt::format("Could write file list: {}.", filesPath);
    }

#endif
    return EXIT_SUCCESS;
}
